window.COURSE_DATA = (function() {
/*
| No. | Question | Answer |
| :-- | :--- | :--- |
| 1 | HTTP và API khác và giống nhau điểm gì? | Khác nhau:<br>- HTTP (HyperText Transfer Protocol Secure): Là giao thức mạng dùng để truyền tải dữ liệu an toàn (mã hóa SSL/TLS). Nó hoạt động ở tầng giao thức mạng.<br>- API (Application Programming Interface): Là tập hợp quy tắc cho phép các ứng dụng giao tiếp với nhau (lấy dữ liệu, gửi lệnh). Nó hoạt động ở tầng ứng dụng.<br><br>Mối liên hệ:<br>- API thường sử dụng giao thức HTTP/HTTPS làm phương tiện để truyền tải dữ liệu giữa Client và Server (đặc biệt là RESTful API). HTTPS đóng vai trò "đường ống" bảo mật cho API hoạt động. |
| 2 | Mối liên hệ giữa HTTP và Session Cookies, Token? | - Vấn đề: HTTP là giao thức không trạng thái (stateless). Server không biết 2 request liên tiếp có phải từ cùng 1 người hay không (ví dụ: vừa đăng nhập xong, chuyển trang lại bị bắt đăng nhập lại).<br>- Giải pháp: Session Cookies và Token sinh ra để khắc phục điều này. Chúng được gửi kèm trong mỗi request để "nhắc" Server biết "đây là user đã đăng nhập", giúp duy trì phiên làm việc mà không cần đăng nhập lại liên tục. |
| 3 | Token là gì? Cách lấy (get) và sửa (edit) Token trên Chrome để test? | 1. Định nghĩa: Token (thường là JWT) là chuỗi mã hóa chứa thông tin xác thực, được Server cấp sau khi đăng nhập. Client lưu lại và gửi kèm trong Header các request sau.<br><br>2. Cách lấy Token (Chrome):<br>- F12 -> Tab Application -> Local Storage (hoặc Session Storage/Cookies) -> Tìm key `authToken` hoặc `accessToken`.<br><br>3. Các logic Test quan trọng:<br>- Test Logout: Kiểm tra xem khi logout, token cũ có bị vô hiệu hóa (kill) không.<br>- Test chiếm quyền (User A dùng Token User B):<br>  + Lấy Token User B -> Gán vào Local Storage của trình duyệt đang login User A -> F5.<br>  + *Kỳ vọng:* Hệ thống phải phát hiện và yêu cầu login lại (hoặc nếu token hợp lệ thì hiển thị đúng data User B nhưng phải đảm bảo đúng quyền).<br>- Test sửa Token (Tampering):<br>  + Lấy Token User A -> Paste vào trang `jwt.io` -> Sửa thông tin (payload) trong cột Decoded (VD: sửa `admin: false` thành `true`) -> Copy chuỗi Encoded mới -> Paste lại vào Local Storage -> F5.<br>  + *Kỳ vọng:* Server từ chối token đã bị sửa đổi (Signature verify fail) và yêu cầu login lại. |
| 4 | Session là gì? Session Cookie hoạt động ra sao? | - Session: Một phiên làm việc duy trì từ lúc user mở trình duyệt đến khi tắt đi.<br>- Cơ chế: Server tạo file Session chứa dữ liệu user và lưu trên Server (có Session ID). Session ID này được lưu dưới dạng Cookie ở trình duyệt (Client). Mỗi khi Client gửi request, nó kèm theo Cookie chứa Session ID để Server so khớp và nhận diện user. Khi logout, dữ liệu Session trên Server sẽ bị xóa. |
| 5 | Cookie là gì? | Cookie là các tệp dữ liệu nhỏ được lưu trữ trên máy tính của người dùng (Client). Website dùng cookie để ghi nhớ thông tin (như trạng thái đăng nhập, giỏ hàng, xu hướng người dùng) nhằm phục vụ cho các lần truy cập sau hoặc duy trì phiên làm việc. |
| 6 | Functional Test và Non-functional Test là gì? | - Functional Test: Kiểm thử chức năng. Kiểm tra xem hệ thống có làm đúng những gì yêu cầu không (Input A ra Output B).<br>- Non-functional Test: Kiểm thử phi chức năng. Kiểm tra cách hệ thống vận hành (Hiệu năng, bảo mật, khả năng chịu tải, tính dễ sử dụng...). Ví dụ: Load test, Stress test. |
| 7 | Phân biệt Bug FE (Frontend) và Bug API (Backend)? | *(Phần này đại ca chưa có câu trả lời, em bổ sung logic chuẩn)*<br>Cách phân biệt nhanh nhất là dùng F12 -> Tab Network:<br>- Bug API (BE): <br>  + Request gửi đi đúng nhưng Response trả về lỗi (Status 500, 400, 404...).<br>  + Hoặc Response trả về data sai so với DB/Logic nghiệp vụ.<br>- Bug FE: <br>  + Response từ API trả về đúng và đẹp, nhưng giao diện hiển thị sai, lệch, hoặc không hiển thị.<br>  + Các lỗi về validate form ở phía client, lỗi layout, click button không phản hồi (do JS chết). |
| 8 | Requirement: "App phải load 100 data trong 10s". Đây là Functional hay Non-functional test? | Đây là trường hợp giao thoa:<br>- Functional: Hệ thống *phải* load đủ và đúng 100 data.<br>- Non-functional: Hệ thống *phải* load xong trong vòng 10 giây (Performance constraint).<br>=> Khi test, phải đảm bảo cả 2 yếu tố: Đủ dữ liệu VÀ đúng thời gian quy định (thường được coi là tiêu chí nghiệm thu phi chức năng nhưng bắt buộc phải đạt). |
| 9 | Test XSS như thế nào? | XSS (Cross-site Scripting) là kỹ thuật tấn công chèn mã độc (Javascript).<br>Cách test: Nhập các đoạn script vào các ô input (Username, Comment, Search...) hoặc trên URL.<br>- *Ví dụ:* Nhập `<script>alert('Hacked')</script>`<br>- *Kỳ vọng:* Hệ thống hiển thị đoạn text đó như văn bản thường (đã escape).<br>- *Lỗi:* Nếu một hộp thoại alert hiện lên -> Dev chưa filter input đầu vào -> Có bug. |
| 10 | Phương pháp All-pair (Pairwise)? | Là kỹ thuật thiết kế Test Case dựa trên việc kết hợp các cặp tham số đầu vào. Thay vì test tất cả các tổ hợp, ta chỉ test các cặp giá trị để tối ưu số lượng test case mà vẫn đảm bảo độ bao phủ chất lượng tốt. <br><br> n paramaters <br>↓<br> giảm combination <br>↓<br> vẫn cover interaction|
| 11 | Ví dụ Test Permission bằng cách change ID (IDOR)? | Kịch bản: User thường (User A) cố tình xóa dữ liệu của User khác (User B) hoặc Admin.<br>Cách làm:<br>1. Nhấn nút xóa Item của mình (Item 1).<br>2. Bắt request lại (Dùng Burp Suite hoặc F12/Network/Edit & Resend).<br>3. Tìm tham số ID (VD: `id=1`) và sửa thành ID của người khác (VD: `id=2`).<br>4. Gửi request.<br>Kỳ vọng: Server trả về lỗi "Unauthorized" hoặc "Forbidden". Nếu Item 2 bị xóa -> Lỗi bảo mật nghiêm trọng. |
| 12 | Vì sao Dev fix/test OK mà QC test vẫn lỗi? | Nguyên nhân phổ biến nhất là do Cache.<br>- Trình duyệt QC vẫn lưu Cache cũ (JS, CSS) hoặc Local Storage cũ.<br>Giải pháp: QC cần xóa Cache (Ctrl+Shift+R) hoặc xóa Local Storage (F12 -> Application -> Clear Storage) trước khi test lại. |
| 13 | Test Layout và Test UI có khác nhau không? | Về lý thuyết thì khác, thực tế Layout là tập con của UI.<br>- Test Layout: Chuyên sâu về bố cục, dàn trang, khoảng cách (margin/padding), sự cân đối, vị trí ảnh/text, responsive trên các màn hình khác nhau (ngang/dọc).<br>- Test UI (GUI): Bao quát hơn, gồm cả Layout + Màu sắc + Font chữ + Các thành phần tương tác (nút bấm, input) + Tính thẩm mỹ tổng thể. |
| 14 | Web App và Native App (Natural App) khác gì nhau? | - Web App: Chạy trên trình duyệt (Chrome, Safari...), không cần cài đặt, phụ thuộc kết nối Internet.<br>- Native App: Ứng dụng cài đặt trực tiếp trên thiết bị (Android/iOS), tận dụng tốt phần cứng (Camera, GPS, Notification) và có thể chạy offline một số tính năng. |
| 15 | Branch coverage vs Statement coverage? | Đây là các kỹ thuật trong White-box testing:<br>- Statement Coverage: Đảm bảo mọi dòng code (câu lệnh) được chạy qua ít nhất 1 lần.<br>- Branch Coverage: Đảm bảo mọi nhánh của code (IF - ELSE) đều được kiểm tra (VD: phải test cả trường hợp đi vào nhánh Đúng và nhánh Sai). |
| 16 | Khác nhau giữa Exception Testing và Validation Testing? | - Validation Testing: Kiểm tra xem phần mềm có làm đúng yêu cầu (Requirement) hay không (Happy path).<br>- Exception Testing: Kiểm tra khả năng xử lý lỗi của phần mềm khi gặp điều kiện bất thường (Bad path, ngoại lệ). Mục đích để đảm bảo app không bị crash khi gặp lỗi. |
| 17 | Khác nhau giữa Automation Tool cho Regression và Performance? | - Regression Tool (Hồi quy): Ghi lại thao tác (Record) và chạy lại (Playback) để đảm bảo chức năng cũ vẫn chạy đúng sau khi update code (VD: Selenium).<br>- Performance Tool (Hiệu năng): Giả lập hàng nghìn User truy cập cùng lúc để đo sức chịu tải của Server (VD: JMeter). |
| 18 | Glass-box testing là gì? | Là tên gọi khác của White-box testing (Kiểm thử hộp trắng). Người test nhìn thấy và hiểu cấu trúc code bên trong để thiết kế test case. |
| 19 | ODBC là gì? | Open Database Connectivity: Một chuẩn giao tiếp (API) giúp ứng dụng kết nối và truy vấn đến các hệ quản trị cơ sở dữ liệu (DBMS) khác nhau mà không phụ thuộc vào ngôn ngữ lập trình hay loại database cụ thể. Nó dùng SQL làm cầu nối. |
| 20 | Key injection test thường dùng ký tự gì? | Thường dùng các ký tự đặc biệt của SQL để test lỗi SQL Injection.<br>- Các ký tự phổ biến: `'` (dấu nháy đơn), `--` (comment trong SQL), `##`, `1=1`, `;`. |
| 21 | Web chạy trên Mobile và Web trên Desktop khác nhau điểm nào? | Khác biệt lớn nhất là Layout (Bố cục) và Responsive.<br>- Web Mobile phải tối ưu cho màn hình dọc, nhỏ, thao tác cảm ứng (touch).<br>- Web Desktop tối ưu cho màn hình ngang, lớn, thao tác chuột (click).<br>- Cần test kỹ việc vỡ khung, ẩn nội dung khi chuyển đổi giữa các thiết bị. |
| 22 | Hệ thống log bug (theo dõi lỗi) nào phổ biến và đặc điểm của chúng? | 1. TestTrack Pro (Leapfrog):<br>- *Nhược điểm:* Mất session sau 20 phút.<br>- *Ưu điểm:* Bộ lọc (filter) bug cực kỳ tốt và hiệu quả.<br><br>2. Frog Bug (Evernote):<br>- *Nhược điểm:* Tìm kiếm bug rất kém. Ví dụ: Tìm theo từ khóa có trong summary nhưng không ra kết quả; hoặc khi không có kết quả thì trang web trắng trơn (không báo "No results"), gây hiểu lầm là lỗi hệ thống.<br><br>3. Unfuddle (Synaptics):<br>- *Đặc điểm:* Khi tìm kiếm theo từ khóa, nó tìm cả trong summary lẫn comment. Điều này khiến kết quả trả về quá nhiều, bị loãng (ví dụ chỉ có 5 bug nhưng ra vài trang kết quả do comment chứa từ khóa).<br><br>4. Jira / Jila:<br>- *Đặc điểm:* Rất thông dụng. Khả năng tìm kiếm bug ở mức ổn, không tệ nhưng chưa bằng TestTrack Pro.<br><br>5. Track Gear (LTRC):<br>- Một hệ thống khác cũng được sử dụng. |
| 23 | Các hệ thống log test case (quản lý ca kiểm thử)? | 1. Rarely (Có phí):<br>- *Tính năng:* Rất hay. Cho phép chạy một bộ Test Case (TC) trên nhiều trình duyệt (browser) và báo cáo kết quả (Pass/Fail) đồng thời trên cả 3 trình duyệt, có biểu đồ so sánh.<br><br>2. Test Topia & Aptech Manager (Miễn phí):<br>- *Nhược điểm:* Chỉ xem được trạng thái trên 1 trình duyệt tại một thời điểm. Muốn biết kết quả trên trình duyệt khác thì phải vào bộ TC đó chạy lại trên trình duyệt kia mới biết được.<br><br>3. TFS (Team Foundation Server):<br>- Hiện tại được dùng tại KMS (dự án Alere) để log bug. |
| 24 | Hệ thống keep track test case (theo dõi tiến độ)? | Test Director: Được sử dụng để theo dõi và quản lý test case. |
| 25 | Test case là gì? Cấu trúc và thế nào là Test case tốt nhất? | Định nghĩa: Test case là tập hợp các điều kiện, biến đầu vào và kết quả mong đợi để xác định xem một chức năng của ứng dụng có hoạt động đúng hay không.<br><br>Cấu trúc cơ bản:<br>- Test Case ID<br>- Test Description (Mô tả)<br>- Pre-condition (Điều kiện tiền đề)<br>- Test Steps (Các bước thực hiện)<br>- Test Data (Dữ liệu kiểm thử)<br>- Expected Result (Kết quả mong đợi)<br><br>Test case tốt nhất: Là bộ test case bao phủ (cover) tất cả các chức năng và tình huống có thể xảy ra. Hệ thống được đánh giá là tốt khi chạy xong bộ test case này thì không còn bug nào xuất hiện nữa. |
| 26 | Bug report là gì? Cấu trúc của một bug report? | Định nghĩa: Là văn bản mô tả chi tiết về lỗi xảy ra để lập trình viên (Dev) có thể hiểu và sửa lỗi.<br><br>Cấu trúc:<br>1. Prefix [Environment]: Môi trường xảy ra lỗi.<br>2. Bug Title: Tiêu đề tóm tắt lỗi.<br>3. Priority: Độ ưu tiên.<br>4. Test Steps: Các bước tái hiện lỗi.<br>5. Actual Result: Kết quả thực tế sai lệch.<br>6. Expected Result: Kết quả mong đợi đúng.<br>7. Screenshot/Video: Hình ảnh/Video bằng chứng. |
| 27 | Lập Test plan để làm gì? Các thành phần của 1 Test plan? | Mục đích: Để xác định phạm vi, cách tiếp cận, nguồn lực và lịch trình cho các hoạt động kiểm thử.<br><br>Các thành phần chính:<br>1. Phạm vi kiểm thử (Scope: In-scope/Out-scope).<br>2. Chiến lược kiểm thử (Test Strategy).<br>3. Tài nguyên & Nhân sự (Resources & Roles).<br>4. Lịch trình (Schedule).<br>5. Môi trường kiểm thử (Test Environment).<br>6. Rủi ro và giả định (Risks & Assumptions).<br>7. Tiêu chí bắt đầu/kết thúc (Entry/Exit Criteria). |
| 28 | Black box testing (Kiểm thử hộp đen) là gì? | Định nghĩa: Là phương pháp test mà không cần biết cấu trúc code hay logic bên trong. Tester chỉ quan tâm đến đầu vào (Input) và đầu ra (Output).<br><br>Ví dụ: Khi test một ứng dụng, SQA chỉ cần biết nhập dữ liệu gì là hợp lệ và kết quả trả về là gì, không cần biết chương trình xử lý thế nào. Điều này cho phép Tester và Developer làm việc độc lập. |
| 29 | White box testing (Kiểm thử hộp trắng) là gì? | Là phương pháp kiểm thử cấu trúc bên trong, logic code và luồng dữ liệu của phần mềm. Thường được thực hiện trong giai đoạn Unit Test bởi chính Developer. |
| 30 | Sự khác nhau giữa SQA và PQA? | PQA (Process Quality Assurance):<br>- *Nhiệm vụ:* Bảo đảm chất lượng quy trình.<br>- *Công việc:* Xây dựng quy trình chuẩn (ISO, CMMI) và giám sát việc thực hiện quy trình của từng bộ phận/dự án để đưa ra cải tiến.<br><br>SQA (Software Quality Assurance):<br>- *Nhiệm vụ:* Bảo đảm chất lượng phần mềm (sản phẩm).<br>- *Công việc:* Test sau khi QC đã test (hoặc test các giai đoạn trung gian) để đảm bảo tính nhất quán của sản phẩm trước khi giao khách hàng. SQA chịu trách nhiệm với khách hàng và cần biết các điểm quan trọng (quickpoint) để test. |
| 31 | Sự khác nhau giữa QA và QC? Nghề nào vất vả hơn? | QC (Quality Control - Tester):<br>- *Nhiệm vụ:* Chạy chương trình, review code để tìm lỗi (bug). Kiểm tra sản phẩm có đúng thiết kế và nghiệp vụ (business) không.<br>- *Tính chất:* Thiên về kỹ thuật, làm việc trực tiếp với phần mềm.<br><br>QA (Quality Assurance):<br>- *Nhiệm vụ:* Giám sát quy trình, đảm bảo đội dự án tuân thủ template, quy trình chuẩn.<br>- *Tính chất:* Thiên về "giấy tờ", quy trình, cần kiến thức tổng hợp và kinh nghiệm quản lý.<br><br>Ai vất vả hơn?<br>- Ngang nhau, tùy dự án. QA giống "chăm con mọn", nhiều việc không tên, hay OT. Tester chịu áp lực tiến độ (Dev làm chậm Tester phải gánh), áp lực để lọt bug (như thủ môn bắt bóng: bắt tốt thì hòa, để lọt lưới thì bị chửi). |
| 32 | Khi nào dừng việc kiểm thử phần mềm? | Khi phần mềm không còn được người dùng cuối (End-user) sử dụng nữa. (Hoặc khi đạt tiêu chí dừng test như: hết ngân sách, hết thời gian, đạt độ bao phủ yêu cầu - nhưng câu trả lời tối ưu nhất theo logic hệ thống là khi vòng đời sản phẩm kết thúc). |
| 33 | Quy trình test (Testing Process) gồm những gì? | Testing là một giai đoạn trong quy trình phát triển phần mềm (SDLC), thường nằm ở nhánh phải của mô hình V-Model.<br><br>Các bước chính:<br>1. Requirement Analysis (Phân tích yêu cầu/Design).<br>2. Test Planning (Lập kế hoạch: loại test, tài nguyên, thời gian, rủi ro).<br>3. Test Case Development (Viết test case).<br>4. Test Execution (Thực hiện test các cấp độ).<br>5. Bug Reporting (Báo cáo lỗi).<br>6. Test Closure (Đóng gói kiểm thử). |
| 34 | Vòng đời của một con bug (Bug Lifecycle)? | 1. New: Bug mới được log.<br>2. Open: Leader duyệt và assign cho Dev.<br>3. In Progress/Fixing: Dev đang sửa.<br>4. Fixed: Dev đã sửa xong.<br>5. Pending Retest: Chờ Tester kiểm tra lại.<br>6. Retest:<br>   - Nếu hết lỗi -> Closed/Verified.<br>   - Nếu còn lỗi -> Reopen (quay lại cho Dev sửa). |
| 35 | Testing bắt đầu từ giai đoạn nào? | Bắt đầu ngay từ giai đoạn lấy yêu cầu (Requirement) và thiết kế (Design) - hay còn gọi là Early Testing. |
| 36 | Các mô hình phát triển phần mềm phổ biến? | - V-model (Mô hình chữ V - Kiểm thử song song phát triển).<br>- Scrum/Agile (Linh hoạt, chia nhỏ sprint).<br>- Waterfall (Thác nước - Tuần tự, hơi lỗi thời nhưng vẫn có nơi dùng). |
| 37 | Acceptance Test và Regression Test là gì? | Acceptance Test (Kiểm thử chấp nhận): Test để xác nhận hệ thống có thỏa mãn các tiêu chí chấp nhận của khách hàng/người dùng cuối hay không (giai đoạn cuối trước khi release).<br><br>Regression Test (Kiểm thử hồi quy): Test lại phần mềm sau khi có code mới hoặc sửa lỗi, để đảm bảo code mới không làm hỏng các chức năng cũ đang chạy tốt. |
| 38 | Value và Value type là gì? | Value: Giá trị đầu vào/đầu ra cụ thể.<br>Value type: Kiểu dữ liệu (String, int, float, boolean...). |
| 39 | Verification & Validation khác nhau thế nào? | Verification (Kiểm chứng): *Do the things right?*<br>- Kiểm tra xem phần mềm có làm ĐÚNG theo tài liệu đặc tả (Spec) không.<br>- *Ví dụ:* Spec yêu cầu nhập chữ -> Test nhập chữ xem có vào không.<br><br>Validation (Thẩm định): *Do the right things?*<br>- Kiểm tra xem chức năng đã làm (dù đúng Spec) có PHÙ HỢP với nhu cầu người dùng cuối không.<br>- *Ví dụ:* Nhập chữ nhưng font chữ quá nhỏ, màu khó nhìn, hoặc nhập mã độc (XSS) mà không chặn -> Sai về Validation (trải nghiệm/an toàn). |
| 40 | Test Function khác Test Scenario chỗ nào? | Test Function:<br>- Dùng trong Functional Test.<br>- Thực hiện Test Case cho từng chức năng riêng biệt hoặc kết hợp logic.<br>- Cần kẻ bảng rule nếu chức năng phức tạp.<br><br>Test Scenario (Kịch bản):<br>- Dùng nhiều trong Performance Test hoặc UAT.<br>- Là một kịch bản gồm nhiều bước (Test Case) được dựng lên theo góc nhìn và luồng đi của User thực tế.<br>- *Lưu ý:* Cần vẽ flow để không sót trạng thái (state transaction). |
| 41 | Các phương pháp test (Test Method)? | - White box: Test code/cấu trúc.<br>- Black box: Test input/output.<br>- Grey box: Kết hợp cả hai (Tester cần hiểu thuật toán/SQL/cấu trúc dữ liệu nhưng vẫn test trên khía cạnh End-user). |
| 42 | Functional Testing (Kiểm thử chức năng) là gì? | Kiểm tra các tính năng của hệ thống có hoạt động đúng theo yêu cầu thiết kế không (Ví dụ: Login, Search, Add to cart...). |
| 43 | Integration Testing (Kiểm thử tích hợp) là gì? | Kiểm tra sự tương tác và truyền dữ liệu giữa các module/thành phần khác nhau sau khi chúng đã được tích hợp lại. |
| 44 | System Testing (Kiểm thử hệ thống) là gì? | Kiểm tra toàn bộ hệ thống hoàn chỉnh (tích hợp đầy đủ) để đảm bảo đáp ứng yêu cầu chức năng và phi chức năng. |
| 45 | Alpha Testing là gì? | - Là giai đoạn test tại nơi sản xuất.<br>- Đối tượng: Nhóm test nội bộ hoặc một lượng khách hàng tiềm năng giới hạn.<br>- Yêu cầu: Ký cam kết bảo mật thông tin (vì sản phẩm chưa public). |
| 46 | Beta Testing là gì? | - Thực hiện sau Alpha Testing.<br>- Phát hành bản build (Beta) cho một lượng người dùng nhất định dùng thử trong thời gian thực tế.<br>- Mục đích: Thu thập lỗi từ người dùng thực để nhà cung cấp sửa chữa lần cuối trước khi ra mắt chính thức. |
| 47 | Unit Test là gì? | Test trên đơn vị nhỏ nhất của phần mềm (hàm, class, method). Ngày nay giai đoạn này thường do Developer tự thực hiện. |
| 48 | Shakeout Testing (hoặc Configuration Test)? | - Test về cấu hình, kết nối mạng, CSDL, môi trường.<br>- Do nhóm quản lý cấu hình thực hiện để thiết lập môi trường test.<br>- Kiểm tra xem các chức năng chính có "sống" không trước khi vào System Test (Yêu cầu Pass 100% mới được qua bước sau). |
| 49 | Có test database không? | Có.<br>- Cần đọc kiến thức Database Basic.<br>- Cần áp dụng test SQL Injection (lỗ hổng bảo mật) theo các mẫu test chuẩn. |
| 50 | Cái nào quan trọng nhất: (A) Đúng nhu cầu người dùng hay (B) Tìm lỗi? | Đáp án A. Kiểm tra hệ thống có đúng với những nhu cầu người dùng quan trọng hơn. (Vì phần mềm không lỗi mà người dùng không dùng được thì vô nghĩa). |
| 51 | Kết quả PASSED khi chạy test case có luôn tốt không? | Chưa chắc.<br>- Ví dụ: Hệ thống báo "Insert thành công" (Passed UI) nhưng thực tế trong Database chưa có dữ liệu -> Cần kiểm tra sâu hơn (xuống DB check). |
| 52 | Làm gì khi Project có tài liệu (document) không rõ ràng? | Quy trình xử lý:<br>1. Investigate (điều tra) luồng công việc (workflow).<br>2. Tìm lại layout cũ hoặc hỏi BA.<br>3. Hỏi Dev đang làm xem họ hiểu rule thế nào.<br>4. Chỗ nào chưa rõ (clear) thì confirm lại với Client/BA.<br>5. Viết Test case (vừa test vừa hoàn thiện).<br>6. Cập nhật lại Test case sau khi nắm rõ chức năng. |
| 53 | Khi kết quả thực tế (Actual) khác kết quả mong đợi (Expected), bạn làm gì? | Xem xét kết quả thực tế đó có phù hợp/tốt cho End-user không:<br>- Nếu có lợi cho User: Đề xuất BA cập nhật Spec.<br>- Nếu không: Log bug. |
| 54 | Định nghĩa một Tester tốt? | Cẩn thận, luôn hướng tới nhu cầu của End-user, bám sát requirement (yêu cầu), và cuối cùng là có kỹ năng giao tiếp hài hước (để giảm căng thẳng với Dev). |
| 55 | Làm gì khi Dev không tái hiện (reproduce) được bug bạn log? | Kiểm tra kỹ lại môi trường:<br>1. Xóa Cache.<br>2. Chạy tab ẩn danh (Incognito).<br>3. Xóa Local Storage.<br>4. Kiểm tra đúng phiên bản Build chưa.<br>-> Nếu vẫn bị thì demo trực tiếp cho Dev xem. |
| 56 | Rõ ràng là bug nhưng Dev không chịu sửa (Won't fix)? | - Chứng minh trong Spec có đề cập -> Dev sẽ phải sửa.<br>- Nếu Spec phi lý -> Escalate (báo cáo lên) cho BA giải quyết. |
| 57 | Các giai đoạn test và đối tượng test? | 1. Unit Test: Code, hàm (Dev làm).<br>2. Integration Test: Các module tích hợp.<br>3. System Test: Toàn bộ hệ thống.<br>4. Acceptance Test: Nghiệp vụ, nhu cầu khách hàng. |
| 58 | Sự khác nhau giữa Regression Testing và Re-testing? | Re-testing: Test lại đúng chức năng/con bug vừa được sửa xem hết lỗi chưa (không làm gì thêm).<br>Regression Testing: Test lại chức năng đó VÀ các chức năng liên quan (ảnh hưởng) để đảm bảo việc sửa lỗi không sinh ra lỗi mới. |
| 59 | Nhiều Test case nhưng không đủ thời gian test, giải pháp là gì? | 1. Cập nhật lại Scope (phạm vi) -> Thỏa thuận lại ngày giao hàng với khách.<br>2. Thực hiện Smoke Test (test tính năng chính).<br>3. Ưu tiên Verification (chạy đúng Spec trước).<br>4. Thực hiện Ad-hoc test.<br>5. Set Priority (Độ ưu tiên):<br>   - High priority: Test kỹ.<br>   - Low priority: Bỏ qua nếu không kịp.<br>6. Nếu bản build lỗi chức năng chính -> Reject ngay để đỡ tốn thời gian. |
| 60 | Test Tool có giá trị không? Tại sao? | Có.<br>1. Giải quyết vấn đề thiếu tài nguyên (ví dụ: 1 case cần chạy 100 lần, tool chạy nhanh hơn người).<br>2. Giảm thời gian Regression Test.<br>3. Test được các môi trường đặc biệt (ví dụ: Load test 1000 người truy cập cùng lúc -> Manual không làm được). |
| 61 | Liệt kê 3 loại Test tool và công dụng? | 1. QTP (Có phí): Hỗ trợ Win, Web... Script viết bằng VB, test được trên nhiều trình duyệt, hỗ trợ làm việc nhóm.<br>2. OpenSTA (Free/Phí plugin): Chuyên dùng test Performance cho Web, chạy trên Win.<br>3. Selenium (Free):<br>   - Test trên nhiều trình duyệt cùng lúc.<br>   - IDE: Record thao tác.<br>   - RC/Grid: Chạy script trên nhiều trình duyệt/máy khác nhau. |
| 62 | Tên 2 chuẩn tham khảo để test? | TMM (Test Maturity Model) và CMMI (Capability Maturity Model Integration). |
| 63 | Tại sao Testing lại cần thiết? | Giúp tăng lợi nhuận thông qua việc giảm chi phí sửa lỗi. Quy tắc 1-10-100: 1 đồng bỏ ra ngăn ngừa lỗi (Design/Test sớm) sẽ giảm được 10 đồng kiểm soát và 100 đồng khắc phục sự cố khi lỗi đã ra thị trường. |
| 64 | Early Testing là gì? | - Tham gia test từ giai đoạn Design/Requirement (chưa có code).<br>- Dev và Test cùng làm rõ (clarify) Spec, Workflow.<br>- Mục đích: Thống nhất cách hiểu, giúp Dev code đúng ngay từ đầu (giống bộ test case của Tester).<br>- Giảm thiểu bug do hiểu sai Spec, tránh việc Reject build nhiều lần. |
| 65 | Static Testing (Kiểm thử tĩnh) là gì? 3 kỹ thuật? | Định nghĩa: Test trên tài liệu/code mà không chạy chương trình (dùng đầu óc và giấy bút). Kiểm tra tính logic, hợp lý của Spec.<br>3 kỹ thuật:<br>1. Informal Reviews (Review không chính thức).<br>2. Technical Reviews (Review kỹ thuật).<br>3. Static Analysis (Phân tích tĩnh bằng tool - Data Flow/Control Flow). |
| 66 | Độ ưu tiên trong Bug (Priority)? | 1. Critical: Lỗi nghiêm trọng, sập hệ thống, mất dữ liệu -> Fix ngay lập tức.<br>2. High: Lỗi chức năng chính, ảnh hưởng lớn -> Fix trong bản build tới.<br>3. Medium: Lỗi chức năng phụ, work-around được -> Fix sau.<br>4. Low: Lỗi giao diện nhỏ, chính tả -> Fix khi rảnh. |
| 67 | Test yêu cầu "Thân thiện" và "Dễ cài đặt" như thế nào? | a. Thân thiện: Kiểm tra xem có thông báo phản hồi (feedback message) ở mọi thao tác không.<br>b. Dễ cài đặt: Kiểm tra xem có tài liệu hướng dẫn (guideline) đi kèm không. |
| 68 | Các phương pháp trong Integration Test? | 1. Big-bang: Gom hết module chạy cùng lúc -> Dễ tìm bug tiềm ẩn do va chạm.<br>2. Incremental: Kết hợp từ từ.<br>3. Top-down: Từ tổng quan xuống chi tiết.<br>4. Bottom-up: Từ chi tiết lên tổng quan.<br>5. Thread: Test theo luồng chức năng lớn. |
| 69 | Mô hình 80-20 trong test? | - System Test: 80% thời gian Dev code, 20% test function.<br>- Acceptance Test: 80% thời gian khách hàng test function, 20% Dev fix bug (nếu có). |
| 70 | Tại sao phải đưa Hợp đồng (Contract) vào kế hoạch Acceptance Test? | Trước khi bắt đầu dự án, khách hàng gửi yêu cầu (Spec) với nhiều tính năng nhưng ít tiền. BA sẽ sửa lại Spec cho phù hợp với ngân sách và ghi vào Hợp đồng. Quá trình làm sẽ theo Spec đã sửa này. Đến lúc Acceptance Test, cần đảm bảo khách hàng test dựa trên Spec trong Hợp đồng (những gì đã chốt) chứ không phải Spec mơ ước ban đầu. |
| 71 | Integration testing in the large là gì? | Là kiểm thử tích hợp mở rộng, test sự kết nối với các hệ thống khác (LAN/WAN, bên thứ 3, plugin, hệ thống nội bộ khác...).<br>Cách tiếp cận: Xác định rủi ro (Risk). Ví dụ: Hệ thống 1 (A, B, C) nối với Hệ thống 2 (A, B', C'). Rủi ro là xung đột giữa B-B' hoặc C-C'. |
| 72 | Maintenance Testing (Kiểm thử bảo trì) là gì? | Là test khi có thay đổi code hoặc tính năng mới trên hệ thống đang vận hành.<br>Nguyên tắc: Chỉ test tính năng mới và đảm bảo các tính năng cũ vẫn chạy tốt. Tester cần biết code mới ảnh hưởng đến vùng nào để khoanh vùng test, không cần test lại toàn bộ hệ thống. |
| 73 | Khách yêu cầu test 500 case trên IE và 500 case trên Firefox. Làm sao tối ưu thời gian? | Giải pháp: Dựa vào kinh nghiệm để so sánh IE và FF.<br>- Với các case về Logic/Input (Verification): Chỉ cần test trên 1 trình duyệt (vì logic server xử lý giống nhau).<br>- Với các case về Giao diện/Validate (Validation - hiển thị lỗi, UI): Test trên cả 2.<br>Kết quả: 500 case IE test trong 10 tuần, nhưng FF chỉ cần 7 tuần (bớt được các case logic đã pass bên IE). |
| 74 | Lưu ý khi "Test follow feel" (Test theo cảm nhận)? | Khi Spec không đồng nhất với người dùng hoặc thiếu tài liệu -> Log bug cho khách hàng (không assign cho Dev vì Dev làm đúng Spec).<br>- Thảo luận với khách để sửa Spec.<br>- Nếu khách không sửa -> Test tiếp theo Spec.<br>Lưu ý: Test theo cảm nhận phụ thuộc vào người test, cần Tester có kinh nghiệm (5 năm+) mới làm tốt được. |
| 75 | TDD là gì? | Test Driven Development: Một phương pháp của Agile. Viết Test case trước, sau đó mới viết code để pass các test case đó. |
| 76 | Early Testing (bổ sung)? | Tương tự TDD nhưng áp dụng ở giai đoạn Design. Dev và Test họp thống nhất rule trước khi làm -> Giảm đáng kể bug do hiểu sai lệch nhau. |
| 77 | Khác biệt giữa Mobile Testing và Web Testing? | 1. Phần cứng (RAM, màn hình).<br>2. Layout (Bố cục).<br>3. Rotate (Xoay màn hình).<br>4. Chữ nhỏ khó đọc.<br>5. Nút Back cứng trên thiết bị khác nút Back trên trình duyệt.<br>6. Tombstone (Trạng thái ngủ đông/phục hồi app).<br>7. Crash (Dễ văng app).<br>8. Shake (Tính năng lắc máy). |
| 78 | IP WAN là gì? Cách lấy IP WAN? | 1. Định nghĩa:<br>- IP WAN (hay còn gọi là Public IP - IP công cộng) là địa chỉ IP được Nhà cung cấp dịch vụ Internet (ISP) cấp cho thiết bị mạng (Router/Modem) của Đại ca.<br>- Chức năng: Nó đóng vai trò như "số nhà" duy nhất trên mạng Internet toàn cầu, giúp hệ thống bên ngoài phân biệt và kết nối được với mạng nội bộ của Đại ca (khác với IP LAN chỉ dùng để giao tiếp trong nội bộ văn phòng/gia đình).<br><br>2. Ứng dụng trong Test:<br>- Dùng để test các tính năng chặn/cho phép truy cập theo khu vực (Geo-blocking).<br>- Test bảo mật (Firewall whitelist/blacklist).<br><br>3. Tool kiểm tra:<br>- Check địa chỉ IP và vị trí địa lý tại: [http://ip2location.com/](http://ip2location.com/) |
| 79 | Tại sao nên tách riêng môi trường Dev và Test? | Để tránh xung đột. Cần: Data riêng, Server riêng, Client riêng.<br>Quy trình: Dev Push code -> Test Pull code về update -> Run test -> Đánh version. |
| 80 | Penetration Testing (Kiểm thử xâm nhập) là gì? Mô tả một phương thức tấn công cụ thể? | 1. Định nghĩa:<br>Là quá trình sử dụng các chuyên gia có kinh nghiệm (Pentester) để thực hiện các cuộc tấn công giả lập vào hệ thống. Mục đích là tìm và vá lỗ hổng trước khi hacker thật sự tìm ra và khai thác.<br><br>2. Phương thức tấn công cụ thể (Ví dụ: SQL Injection):<br>- Kịch bản: Tại màn hình đăng nhập (Login) của website.<br>- Hành động: Thay vì nhập tên đăng nhập bình thường, Tester nhập một đoạn mã lệnh đặc biệt vào ô User, ví dụ: `' OR '1'='1`.<br>- Cơ chế logic: Hệ thống cơ sở dữ liệu (Database) phía sau bị đánh lừa bởi logic toán học: "1 bằng 1" luôn là mệnh đề ĐÚNG (TRUE).<br>- Kết quả: Hệ thống bị lừa, bỏ qua bước kiểm tra mật khẩu và tự động đăng nhập thẳng vào tài khoản quản trị cao nhất (Admin), cho phép hacker đánh cắp toàn bộ dữ liệu khách hàng. |
| 81 | Những hệ thống nào cần thực hiện Penetration Testing? | Mọi thành phần liên quan đến lưu trữ và xử lý thông tin:<br>- Hệ điều hành, Ứng dụng, Database, Thiết bị mạng.<br>- Website, Web-app.<br>- Mạng vành đai (Firewall, Router).<br>- Mạng nội bộ, Mạng không dây.<br>- Kỹ nghệ xã hội (Social Engineering - tấn công vào con người).<br>- Tiếp cận vật lý. |
| 82 | Tại sao cần thực hiện Penetration Testing? | - Giảm thiểu/Ngăn ngừa rủi ro mất doanh thu (do hacker, nhân viên xấu, hệ thống lỗi).<br>- Bảo vệ danh tiếng và niềm tin của khách hàng vào thương hiệu.<br>- Xác định lỗ hổng an ninh để có phản ứng kịp thời và dự trù ngân sách bảo mật hợp lý. |
| 83 | Ưu điểm của mô hình Scrum là gì? | 1. Về Mục tiêu:<br>- Hệ thống nhắm đến các Goal ngắn hạn.<br><br>2. Về Quản lý (PM):<br>- Giúp PM quản lý công việc dễ dàng hơn.<br>- Đảm bảo công việc không bị bỏ sót.<br><br>3. Về Product Owner (PO):<br>- Trách nhiệm: PO có trách nhiệm cao hơn với dự án (Khác với các mô hình khác: PO chỉ đưa Spec -> chờ Release -> sai lệch -> khiếu nại).<br>- Nhận thức: PO luôn nắm bắt được dự án đang đi đến đâu.<br><br>4. Về Kiểm soát tiến độ (Delivery):<br>- Đối tượng: PO và Scrum Master.<br>- Phương pháp: Kiểm soát ngày Delivery thông qua việc so sánh (Compare) số Point làm được của từng Sprint với số Point đã Estimate.<br><br>5. Về Quản trị rủi ro:<br>- Kiểm soát được rủi ro khi có yêu cầu thay đổi Spec. |
| 84 | Khuyết điểm của mô hình Scrum là gì? | 1. Về sự tham gia:<br>- Bắt buộc PO phải tham gia vào quy trình.<br><br>2. Về nhân sự:<br>- Yêu cầu Member phải là Senior. |
| 85 | Trong Scrum có các Role nào và nhiệm vụ chi tiết? | 1. Product Owner (PO)<br>- Hành động 1: Thiết lập độ ưu tiên (Set Priority).<br>- Hành động 2: Phê duyệt (Approve) Estimate User Story Point cho Team.<br>- Hành động 3: Phê duyệt (Approve) Estimate Sprintlog cho Team.<br><br>2. Scrum Master<br>- Hành động 1: Quản lý (Manage) Estimate User Story Point.<br>- Hành động 2: Quản lý (Manage) Estimate Sprintlog và thời gian thực tế (Actual time) của Team -> Sau đó báo cáo (Report) cho PO.<br>- Hành động 3: Thương lượng (Deal) với PO về việc thay đổi ngày giao hàng (Delivery day).<br><br>3. Team Member<br>- Hành động 1: Thực hiện Estimate User Story Point.<br>- Hành động 2: Thực hiện Estimate Sprintlog.<br>- Hành động 3: Thực hiện công việc (Word/Work). |
| 86 | Các mô hình (Model) trong quy trình gồm những gì? | Model: task handling, deploy build, task life circle, bug life circle, process testing, stratergy testing, process handling task for member, process handling task for leader.<br><br>*(Giải thích chi tiết: Đây là danh sách các quy trình vận hành trong dự án. Bạn cần nắm rõ dòng chảy của công việc từ lúc có Task mới -> Dev code -> Deploy -> Test -> Log Bug -> Fix Bug -> Close Task. Mỗi role (Member/Leader) sẽ có trách nhiệm xử lý khác nhau trong từng model).* |
| 87 | Quy trình xử lý khi nhận build mới (Build flow) như thế nào? | Receive new build -> smoke test -> if pass (verify and regression test-execute-adhoc) -> If fail (reject build) -> report and loop again this process.<br><br>*(Giải thích: <br>- Smoke test: Test nhanh các tính năng chính yếu nhất (khoảng 15-30p) để đảm bảo build không bị crash hoặc lỗi nghiêm trọng (Blocker). Nếu Smoke fail -> Trả build ngay (Reject).<br>- Regression test: Test hồi quy để đảm bảo tính năng cũ không bị lỗi do code mới.<br>- Ad-hoc: Test ngẫu nhiên theo kinh nghiệm không theo kịch bản để tìm lỗi tiềm ẩn).* |
| 88 | Vòng đời của Bug (Bug life cycle) diễn ra như thế nào? | New -> assigned -> resolved (fixed-invalid-wonfix-duplicate-move-workforme) -> ready for test -> if pass -> close bug -> if fail -> reopened.<br><br>*(Giải thích trạng thái:<br>- Invalid: Bug không hợp lệ (do hiểu sai spec hoặc lỗi môi trường).<br>- Won't fix: Bug được chấp nhận nhưng sẽ không sửa (do rủi ro thấp hoặc quá tốn kém).<br>- Duplicate: Trùng với bug đã log trước đó.<br>- Works for me: Dev không tái hiện được lỗi (trên máy Dev vẫn chạy đúng).<br>- Reopened: Dev báo fix xong nhưng Tester kiểm tra lại vẫn thấy lỗi).* |
| 89 | Early testing là gì trong quy trình? | Early testing<br><br>*(Giải thích: Là việc bắt đầu hoạt động kiểm thử càng sớm càng tốt trong vòng đời phát triển phần mềm (SDLC). Ví dụ: Review tài liệu requirement ngay từ đầu để tìm lỗi logic trước khi Dev viết code. Lợi ích: Tiết kiệm chi phí và thời gian sửa lỗi).* |
| 90 | Verify là gì? | Verify (make sure the product work properly with spec)<br><br>*(Giải thích: "Are we building the product right?" - Kiểm tra xem sản phẩm có được xây dựng đúng theo thiết kế và tài liệu kỹ thuật hay không. Tập trung vào quy trình và tài liệu).* |
| 91 | Validation là gì? | Validation (make sure the product is the things user needs, spec is logic and consistent with end user. Don't care spec)<br><br>*(Giải thích: "Are we building the right product?" - Kiểm tra xem sản phẩm có đáp ứng đúng nhu cầu thực tế của người dùng hay không, ngay cả khi spec không đề cập. Tập trung vào trải nghiệm và nhu cầu người dùng cuối).* |
| 92 | Các mức độ Priority gồm những gì? | Priority (high-medium-low)<br><br>*(Giải thích: Độ ưu tiên xử lý - Dựa trên góc độ kinh doanh/business. <br>- High: Cần sửa ngay lập tức (ví dụ: lỗi thanh toán, lỗi trang chủ).<br>- Low: Có thể sửa sau (ví dụ: lỗi sai chính tả nhỏ, màu sắc lệch nhẹ)).* |
| 93 | Các mức độ Severity gồm những gì? | Severity (Block-critical-major-normal-minor-enhancement)<br><br>*(Giải thích: Mức độ nghiêm trọng - Dựa trên góc độ kỹ thuật và ảnh hưởng hệ thống.<br>- Blocker: Không thể test tiếp được.<br>- Critical: Chức năng chính chết hoàn toàn.<br>- Minor: Lỗi nhỏ, ít ảnh hưởng chức năng).* |
| 94 | Chiến lược kiểm thử trong thời gian ngắn (Testing in short time) là gì? | Testing in sort time (testing from high priority to low priority [verify+mainfunction-validate])<br><br>*(Giải thích: Khi deadline gấp, không thể chạy hết 100% test case, ta áp dụng chiến lược dựa trên rủi ro (Risk-based testing):<br>1. Chạy các case có Priority cao nhất.<br>2. Test luồng chính (Main flow/Happy case).<br>3. Chỉ test validate sơ bộ, bỏ qua các case biên ít gặp).* |
| 95 | Chiến lược kiểm thử trên nhiều môi trường (Testing on many environments) là gì? | Testing on many environments (run all testcases on a main browser - on another browser testing fucntion regearding to javascript and layout or UI)<br><br>*(Giải thích: Không cần chạy full test case trên mọi trình duyệt/thiết bị vì tốn thời gian. <br>- Chọn 1 trình duyệt chính (VD: Chrome) để chạy Full Test Case.<br>- Các trình duyệt khác (Firefox, Safari, Edge...): Chỉ kiểm tra giao diện (UI) và các chức năng có dùng JavaScript phức tạp).* |
| 96 | Phương pháp TDD là gì? | TDD (Test Driven Development)<br><br>*(Giải thích: Phát triển hướng kiểm thử. Quy trình: Viết Test case trước (Fail) -> Viết Code để pass test case đó (Pass) -> Refactor code cho tối ưu. Giúp code sạch và ít bug).* |
| 97 | Phương pháp BDD là gì? | BDD (Behavior Driven Development)<br><br>*(Giải thích: Phát triển hướng hành vi. Sử dụng ngôn ngữ tự nhiên để mô tả kịch bản test (Given - When - Then) giúp Dev, Tester và khách hàng đều hiểu được. Ví dụ: Given tôi ở trang chủ, When tôi bấm nút Login, Then tôi thấy màn hình Dashboard).* |
| 98 | Ví dụ về phương pháp Boundary (Phân tích giá trị biên)? | Boundary (x>1 -> x=2 & x=1)<br><br>*(Giải thích: Lỗi thường xuất hiện ở các biên của điều kiện input. <br>Ví dụ: Nhập tuổi > 18.<br>- Biên cần test: 18 (biên dưới), 19 (giá trị hợp lệ sát biên), 17 (giá trị không hợp lệ sát biên). <br>- Mục đích: Tìm lỗi tại điểm chuyển giao giữa đúng và sai).* |
| 99 | Ví dụ về phương pháp Equivalence partition (Phân vùng tương đương)? | 1 parameter <br>↓<br> chia nhóm value <br>↓<br> test đại diện<br><br>*(Giải thích: Chia dữ liệu đầu vào thành các nhóm hợp lệ. Nếu test 1 giá trị trong vùng đó đúng thì các giá trị khác cũng đúng.<br>Ví dụ: Nhập số lượng từ 1 đến 100.<br>- Vùng hợp lệ: Chọn đại diện là 50.<br>- Vùng không hợp lệ: Chọn -1 hoặc 101. <br>- Giúp giảm số lượng test case cần chạy).* |
| 100 | Phương pháp Decision table là gì? | Decision table<br><br>*(Giải thích: Bảng quyết định. Dùng khi logic xử lý phụ thuộc vào nhiều điều kiện kết hợp (Conditions) dẫn đến các hành động khác nhau (Actions). <br>Ví dụ: Điều kiện "Khách VIP" + "Mua trên 1 triệu" -> Hành động "Giảm 10%". Bảng này liệt kê tất cả tổ hợp True/False để không sót trường hợp).* |
| 101 | Backup and restore database? | - Full backup data test from data client<br>- There are 2 data (data for dev and data for test)<br>- When find bug -> backup transaction log<br>- When reproduce -> restore full backup -> restore transaction log<br><br>*(Giải thích quy trình xử lý Data khi bắt Bug khó:<br>1. Lấy dữ liệu thật (nếu được phép) hoặc dữ liệu mẫu đầy đủ để làm mốc (Full backup).<br>2. Môi trường Dev và Test phải tách biệt.<br>3. Khi gặp Bug: Ngay lập tức lưu lại Transaction log (lịch sử thao tác DB) tại thời điểm đó.<br>4. Khi Dev cần tái hiện (Reproduce): Restore lại bản Full backup ban đầu + chạy lại Transaction log để đưa hệ thống về đúng trạng thái lúc xảy ra lỗi).* |
| 102 | Kiểm thử Database (Database testing) thực hiện như thế nào? | Database (update on app then querry to check in database - otherwise)<br><br>*(Giải thích: Kiểm tra tính toàn vẹn dữ liệu.<br>- Cách 1: Thao tác trên giao diện (UI) -> Query vào Database xem dữ liệu có lưu đúng không.<br>- Cách 2: Insert/Update trực tiếp trong Database -> Kiểm tra xem lên giao diện có hiển thị đúng không).* |
| 103 | Kiểm thử bảo mật (Security testing) bao gồm những gì? | Security (injection test, login B delete item by id A)<br><br>*(Giải thích: <br>- Injection test: Phổ biến là SQL Injection (chèn câu lệnh SQL độc hại vào input).<br>- Login B delete item by id A (IDOR): Lỗi phân quyền. User B đăng nhập nhưng thay đổi ID trên URL để xóa hoặc xem dữ liệu của User A).* |
| 104 | Kiểm thử chức năng (Function testing) bao gồm những gì? | Function (insert: XSS,...often test with UI(back&forward-feedback&message,...))<br><br>*(Giải thích: Kiểm tra các tính năng hoạt động đúng spec.<br>- Các thao tác CRUD (Thêm, Xóa, Sửa, Xem).<br>- Test điều hướng (Back/Forward trình duyệt có giữ data không?).<br>- Test thông báo (Message thành công/thất bại).<br>- Kiểm tra Input: Bao gồm cả test XSS (Cross-site scripting) - nhập script độc hại vào ô input xem hệ thống có lọc không).* |
| 105 | Kiểm thử hiệu năng (Performance testing) đo lường yếu tố nào? | Performance (response time)<br><br>*(Giải thích: Tập trung vào Response time (Thời gian phản hồi) của hệ thống khi có tải.<br>- Load Testing: Test với lượng user dự kiến.<br>- Stress Testing: Test vượt ngưỡng chịu đựng để xem hệ thống sập như thế nào).* |
| 106 | Mobile testing gồm những gì: | - Localization (format font, time-time zone-language): *(Định dạng giờ, ngôn ngữ vùng miền)*<br>- Tombstone/Interrupt: *(Ngắt quãng: Có cuộc gọi đến, tin nhắn, pin yếu, app chạy nền rồi mở lại có bị crash/mất dữ liệu không?)*<br>- Crash: *(App bị đóng đột ngột)*<br>- Missing: *(Thiếu hình ảnh, dữ liệu)*<br>- Text cut off: *(Chữ bị cắt mất do màn hình bé)*<br>- Overlap/Spill out: *(Chữ/Hình đè lên nhau hoặc tràn ra ngoài khung)*<br>- Wrong navigation: *(Điều hướng sai màn hình)*<br>- Wrong position: *(Sai vị trí hiển thị)*<br>- Block until load complete: *(App bị đơ không thao tác được khi đang loading)*<br>- List empty/ blank page: *(Xử lý khi danh sách trống)*<br>- App don't update data or appear new record after update one record: *(Lỗi refresh dữ liệu)*<br>- First login -> crash or don't display full UI: *(Lỗi lần đầu mở app)*<br>- Go back previour screen (after log out still can goback user screen without login again): *(Lỗi bảo mật: Logout rồi bấm Back vẫn xem được trang cũ)*<br>- Don't redirect to complete screen (still display detail screen after show message complete -> therefore user can submit form again): *(Lỗi duplicate data do user bấm submit được nhiều lần)* |
| 107 | Defference between mobile testing and web. | - Speed: *(Mobile phụ thuộc mạng 3G/4G/Wifi không ổn định)*<br>- Screen: *(Mobile có nhiều kích thước màn hình, độ phân giải khác nhau)*<br>- Layout: *(Mobile ít không gian, bố cục dọc; Web bố cục ngang)*<br>- Rotate: *(Mobile có xoay ngang/dọc màn hình)*<br>- Go back on mobile difference with browser: *(Nút Back cứng trên Android vs nút Back trên trình duyệt)*<br>- Tombstone/interrupt: *(Web ít bị gián đoạn hơn Mobile - cuộc gọi, SMS)*<br>- Crash: *(Mobile App dễ crash do phần cứng/RAM; Web chỉ crash tab trình duyệt)*<br>- Font size is small, hard to reading: *(Vấn đề hiển thị trên màn hình nhỏ)* |
| 108 | Các thành phần chính của Scrum và quy trình 1 task trong Scrum: | - Backlog: *(Danh sách toàn bộ yêu cầu dự án)*<br>- Sprint backlog: *(Danh sách task cam kết làm trong 1 Sprint)*<br>- Sprint planning > estimation > execute > review & report > chang status: <br>*(Quy trình chuẩn:<br>1. Planning: Chọn task và ước lượng point.<br>2. Execute: Dev code, Tester test.<br>3. Daily Scrum: Họp hàng ngày báo cáo tiến độ.<br>4. Review: Demo sản phẩm cuối Sprint.<br>5. Retrospective: Họp rút kinh nghiệm).* |
| 109 | Work Breakdown structure là gì trong Estimation? | Work Breakdown structure (WBS)<br><br>*(Giải thích: Cấu trúc phân chia công việc. Là kỹ thuật chia nhỏ một dự án lớn hoặc một tính năng phức tạp thành các phần nhỏ hơn, dễ quản lý và ước lượng thời gian chính xác hơn. Ví dụ: Tính năng "Login" chia thành: UI, Validate, API connect, Database check).* |
| 110 | Planning poker là gì trong Estimation? | Planning poker<br><br>*(Giải thích: Một kỹ thuật ước lượng trong Scrum (Agile). Các thành viên trong team sử dụng bộ bài (số Fibonacci: 1, 2, 3, 5, 8...) để cùng đưa ra đánh giá về độ khó (Point) của một task. Mục đích: Tránh ảnh hưởng ý kiến đám đông và đạt được sự đồng thuận khách quan).* |
*/
}).toString().match(/\/\*([\s\S]*)\*\//)[1].trim();